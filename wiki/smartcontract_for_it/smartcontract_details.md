# Smart contract for IT Detail Explanation

![](img/smart_contract_detail_header.png)

This chapter contains a detailed explanation about how the IT smart contract is built.
What are the different component that compose it?

## Model of the Smart Contract

This document only describes the meaning of some of the important attributes of the smart contract.
For full details of the types please check the api docs [here](https://explorer.grid.tf/explorer)

The contract model consists of 3 parts:

- The contract section (immutable)
- The reservation section (mutable)
- The workload parameters (immutable)

The parameters are defined entirely when the reservation is created, and is immutable after this, parameters are different based on the workload type.
The state is mutable, and after the reservation has been created, this will be updated continuously by both the customer 3Bot and the farmer 3Bot (and possibly other 3Bots who will sign to trigger actions).

### Contract Model

The reservation contract holds all data related to the blockchain, payments and workload type.

The following fields are available on the contract:

- `id`: Globally unique contract id. Generated by the network. (not filled by the user)
- `node_id`: Node id of where the workload will be deployed. Must be one of the pool nodes.
- `pool_id`: [Capacity pool](capacity_pool) of the funds for that workload contract.
- `customer_tid`: Owner of the contract.
- `signing_request_provision`: Of type [SigningRequest](#signingrequest). Required signatures for this contract to be deployed.
- `signing_request_delete`: Of type [SigningRequest](#signingrequest). Required signatures for this contract to be deleted.
- `workload_type`: Type for workload, based on this type, more parameters will be needed to fullfill the workload.
- `epoch`: Creation date.
- `description`: Description of the contract.
- `metadata`: Extra string metadata related to this contract, the creator can use it to store some information related to his system.

The contract holds information like the contract ID (globally unique), node that will deploy the workload, capacity pool id where the workload is funded.
It also holds information about who can sign for the actual deployment and deletion of the workloads.
All fields in the data object are immutable after the
reservation is created (i.e. the customer signs the data).

### Contract state

The contract state is updated throughout the lifetime of the reservation. It also contains the signatures needed to have the node take action.
The state container fields like:

- `customer_signature`: The signature of the customer owning this contract.
- `next_action`: The next action that need to be taken by the network regarding this contract. (please check contract lifecycle)
- `signature_provision`: Signatures attached to this contract, only signers allowed in the `signing_request_provision` are accepted. Once `quorum_min` is fullfilled, the signature provisioning is started.
- `signature_farmer`: Signature of the farmer.
- `signature_delete`: Signatures attached to this contract, only signers allowed in the `signing_request_delete` are accepted. Once `quorum_min` is fullfilled, the signature deletion is started.

### Reservation parameters

Specific to different workload types. Parameters also can not be changed once the reservation is created.

## Signature validity

A signature is created by signing a piece of data using a private key. Afterwards,
the corresponding public key can be used to check if the signature is valid. A [signature field](#signingsignature) is valid if it meets the following conditions:

- It contains at least the minimum amount of signatures required, as defined in
  the `quorum_min` field of the corresponding [signing request field](#signingrequest), 1 if there is no such corresponding signing request.
- All signatures are valid with a public key owned by a referenced 3Bot (referenced in the aforementioned accompanying [signing request field](#signingrequest) or possibly other fields).

### Signature algorithm

- signature algorithm: [ed25519](https://ed25519.cr.yp.to/)
- public key size: 32 bytes
- private key size: 32 bytes
- signature size: 64 bytes

## Lifecycle

The following is a quick overview of the types used, their fields, and what these fields are used for. 

The following is an overview of the lifecycle of a reservation, and how the `next_action` changes during the lifetime of the contract.

All fields related to the contract lifecycle are under the `state` object. That's the only mutable part of the smart contract. Mutation is done by some authorized API end points (like signing), or by the grid itself (like `next_action`).

- `next_action`: This field describes what action should be performed next. We can simply describe a reservation lifecycle as follows:

  - User create the reservation, initial status is `created.`
  - User sends the reservation to the explorer, status goes from `create` to `sign`.
  - User sign the reservation, status goes from `sign` to `pay`.
  - As a result of registering the reservation on the explorer, the user got a list of transactions to do in other to pay the farmer involved into the reservation. Once the user has actually executed the transactions, the explorer checks the token have actually arrived, the status goes from `pay` to `deploy`. Check the [payment documentation](smartcontract_payment) for more detail information on how to pay for a reservation.
  - When a reservation has a state `deploy`, the node can now pick it up and provision the workloads.

From here there are 2 possibility:

- The pool funds are depleted, it's state goes from `deploy` to `delete`.
- Or the user decides to delete the reservation before it expires. It validates the condition defined in `SignaturesDelete` field. The state does from `deploy` to `delete`.
- When a reservation has a state `delete`. The node decommissions the workloads and reports the workloads to be deleted. Once all workloads have been marked as deleted, the reservation state goes from `delete` to `deleted` and the reservation lifecycle is at the end-state.

- `signatures_provision`: A list of `signatures` needed to start the provisioning (deploy) step.
  i.e. after enough valid signatures are provided here, the nodes can start to deploy the workloads defined. The validity of signatures and the amount of valid signatures required is defined by the `signing_request_provision` field.

- `signature_farmer`: The [signatures](#signingsignature) of the farmer 3Bots, which declares that the farmer agrees to provision the workloads as defined by the reservation once there is consensus about the provisioning.

- `signatures_delete`: Much like `signatures_provision`, however it is used when a currently deployed workload needs to be deleted.

## SigningRequest

A signing request defines who (which 3Bots) can sign for a particular action,
and the minimum amount of required signatures. The minimum amount of people needed
can be anything between 1 and the number of signers.

- `signers`: A list of 3Bot ids who can sign. To verify the signature, the public
  key of the 3Bot can be loaded and then used to verify the signature.
- `quorum_min`: The minimum amount of requested signatures. At least this amount of 3Bots need to sign before the signature request is considered fulfilled.

As an example of how this might be applied in practice, consider the following
signing request:

- `Signers: [3Bot_a, 3Bot_b, 3Bot_c]`
- `QuorumMin: 1`

This means that any of the 3 listed 3Bots can sign the data, and the request is fulfilled as soon as anyone signs. For instance, a workload for testing is used by 3 developers, and any of those can choose to have the workload deployed or deleted.
If however another person signs (perhaps a 4th developer who is new in the company), the signature will not be valid, as he is not listed in the `signers` field. Therefore he is not able to deploy the workload.

Note that `quorum_min` is a _minimum_ and as such, it is possible, and legal, for more than 1 of the listed persons to sign.
I.e. if both `3Bot_a` and `3Bot_b` sign, the request is still fulfilled.

## SigningSignature

A signature has the actual `signature` bytes, as well as the id of the 3Bot which signed. The 3Bot id is used to verify that this 3Bot is actually allowed to sign and to fetch its public key and verify the signature. Additionally, the time of signing is also recorded.

- `tid`: Id of the 3Bot which signed.
- `signature`: The actual signature in binary form.
- `epoch`: Time of signing.

#### Result

A result is used by a Zero-OS node to add a response to a reservation. This result can inform users if an error occurred, or more commonly, it can relay back vital information such as the IP address of a container after it is started.
The result object has a `WorkloadId` field, which is used to map the result to the actual workload. With the workload request, the `NodeId` can be inspected, to get the nodes public key. The key can then be used to verify the signature of the data, proving that it is indeed this node which created the reply, and that the `DataJSON` (TODO:remove this field) has not been tampered with after it was created.

- `category`: The type of workload for which the reply is.
- `workload_id`: The id of the workload for which the reply is. This will be the same as one of the `workload_id`s in the [reservation data](#reservationdata).
- `signature`: The bytes of the signature. The signature is created by the node which creates the reply. The data signed is the `data_json` field. This proves the authenticity of the reply as well as the integrity of the response data.
- `data_json`: actual result pay load (different per category)
- `state`: Did the workload deploy ok ("ok") or not ("error").
- `message`: Content of the message sent by the node (in case of error)
- `epoch`: Time at which the result has been created.
- `node_id`: The node ID of the node that deployed the workload.

## Reservation Flow Diagram

![process](img/grid_provisioning2.png)

## Actors

- **User**: A digital avatar of a user. This is the one buying capacity on the grid.
- **Farmer**: A digital avatar of a farmer. It owns some node in the grid and is responsible to set the price of its node capacity.
- **TF Explorer**: Public directory listing all the nodes/farmers in the grid.
- **Blockchain**: Money blockchain, money transaction are executed on this chain using ThreeFold_Token (TFT).
- **Node**: Hardware running Zero-OS and responsible to provide capacity to the TF Grid.
